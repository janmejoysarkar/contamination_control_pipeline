#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Tue Oct 21 03:31:21 PM CEST 2025
@author: sarkarjj
@hostname: hydra2

DESCRIPTION
- This module generates the flat field for removing contaminant patches.
- Images are aligned and median stack is taken based on reference frame.
- Flat is generated by dividing sun image by median stacked image.
- This is tested for sun-at-center images.
- Align images by cross-correlation for feature rich bands.
- Align images by sun-cent information for continua.
"""
import os
import glob
import numpy as np
import multiprocessing
import astropy.units as u
from scipy.ndimage import zoom
from sunpy.map import Map, MapSequence
from astropy.convolution import convolve, Box2DKernel
from astropy.coordinates import SkyCoord, SkyOffsetFrame
from sunkit_image.coalignment import calculate_match_template_shift, apply_shifts

def blur(data, kernel): #blurring function
    return(convolve(data, Box2DKernel(kernel), normalize_kernel=True))

def get_submap(ref_img):
	"""
	Get a submap from the reference image for template matching.
	Parameters:
	- ref_img: Reference SunPy map image.
	Returns:
	- Submap of the reference image.
	"""
	center_coord = SkyCoord(0 * u.arcsec, 950* u.arcsec, frame=ref_img.coordinate_frame) #54,157
	width = 1100 * u.arcsec
	height =300 * u.arcsec   
	offset_frame = SkyOffsetFrame(origin=center_coord, rotation=0*u.deg)
	rectangle = SkyCoord(lon=[-1/2, 1/2] * width, lat=[-1/2, 1/2] * height, frame=offset_frame)
	ref_submap = ref_img.submap(rectangle) #bottom_left, top_right=top_right)
	return ref_submap

def makeflat(files):
    '''
    Give a list of images spanning not more than 15-20 mins in time.
    Ideal for cleaning 2k NB03 images.
    '''
    template_map= Map(files[0])
    ref_submap = get_submap(template_map)
    ref_cdel=ref_submap.meta['CDELT1']
    seq = Map(files, sequence=True)
    align_shift = calculate_match_template_shift(seq, template=ref_submap)
    shift_xPix = align_shift['x'].value / ref_cdel * -1
    shift_yPix = align_shift['y'].value / ref_cdel * -1
    aligned_maps = apply_shifts(seq, yshift=shift_yPix * u.pixel, xshift=shift_xPix * u.pixel, clip=False)
    aligned_map_arr= np.stack([m.data for m in aligned_maps], axis=0)
    med= np.median(aligned_map_arr, axis=0)
    med[med==0]=1
    flat_frame= template_map.data/med
    flat_frame[flat_frame==0]=1
    flat_frame=flat_frame/blur(flat_frame, 10) # High pass filtering
    flat_frame_4k=zoom(flat_frame, 2, order=0) # Nearest neighbor interpolation
    return flat_frame, flat_frame_4k

def fd_correction(file):
    """
    - To process images taken in the line channels
    NB03, NB04 and NB08
    """
    m= Map(file)
    if 'enable' in m.meta['BIN_EN']:
        corrected_img_data= m.data/flat_frame
    else:
        corrected_img_data= m.data/flat_frame_4k
    corrected_img_data= np.nan_to_num(corrected_img_data, nan=0.0)
    corrected_img_data[corrected_img_data> 6e4]=0
    corrected_map= Map(corrected_img_data, m.meta)
    if SAVE:
        filename= m.meta['F_NAME']
        img_savepath= os.path.join(project_path, f'products/full_disk/{filename}')
        corrected_map.save(img_savepath, overwrite=True)
        if not QUIET: print('FD saved:', filename)

def roi_correction(file):
    '''
    Applies correction to RoI images
    '''
    roi_map= Map(file)
    col, row= roi_map.meta['X1'], roi_map.meta['Y1']
    s_row, s_col= roi_map.meta['NAXIS1'], roi_map.meta['NAXIS2']
    roi_flat= flat_frame_4k [row:row+s_row, col-20:col+s_col-20]
    corrected_roi_data= roi_map.data/roi_flat
    corrected_roi_data= np.nan_to_num(corrected_roi_data, nan=0.0)
    corrected_roi_data[corrected_roi_data> 6e4]=0
    corrected_roi_map= Map(corrected_roi_data, roi_map.meta)
    if SAVE:
        filename= roi_map.meta['F_NAME']
        img_savepath= os.path.join(project_path, f'products/roi/{filename}')
        corrected_roi_map.save(img_savepath, overwrite=True)
        if not QUIET: print('ROI saved:', filename)

if __name__=='__main__':
    SAVE= True # Toggle to save corrected image
    QUIET= False
    project_path= os.path.abspath('..')
    # Filepath for full disk images
    fd_files= sorted(glob.glob(os.path.join(project_path, f'data/raw/full_disk/*.fits'))) # Filepath for full disk images
    # Filepath for ROI images
    roi_files= sorted(glob.glob(os.path.join(project_path, 'data/raw/roi/*.fits')))
    flat_frame, flat_frame_4k= makeflat(fd_files[:15]) # Make flat file. Global variable
    with multiprocessing.Pool() as pool:
        r1= pool.map_async(fd_correction, fd_files)
        if roi_files: # Check if roi_files is empty. Will run if not empty.
            r2= pool.map_async(roi_correction, roi_files)
            r1.get() # get() stops process if error is received. Use wait() for continued run, with errors.
            r2.get()
        else:
            r1.get()
