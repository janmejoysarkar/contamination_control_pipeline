#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Tue Oct 21 03:31:21 PM CEST 2025
@author: sarkarjj
@hostname: hydra2

DESCRIPTION
- This module generates the flat field for removing contaminant patches.
- Images are aligned and median stack is taken based on reference frame.
- Flat is generated by dividing sun image by median stacked image.
- This is tested for sun-at-center images.
- Align images by cross-correlation for feature rich bands.
- Align images by sun-cent information for continua.
"""
import os
import sys
import glob
import numpy as np
import multiprocessing
import astropy.units as u
from astropy.io import fits
import matplotlib.pyplot as plt
from sunpy.map import Map, MapSequence
from astropy.coordinates import SkyCoord, SkyOffsetFrame
from sunkit_image.coalignment import calculate_match_template_shift, apply_shifts

def get_submap(ref_img):
	"""
	Get a submap from the reference image for template matching.
	Parameters:
	- ref_img: Reference SunPy map image.
	Returns:
	- Submap of the reference image.
	"""
	center_coord = SkyCoord(0 * u.arcsec, 950* u.arcsec, frame=ref_img.coordinate_frame) #54,157
	width = 1100 * u.arcsec
	height =300 * u.arcsec   
	offset_frame = SkyOffsetFrame(origin=center_coord, rotation=0*u.deg)
	rectangle = SkyCoord(lon=[-1/2, 1/2] * width, lat=[-1/2, 1/2] * height, frame=offset_frame)
	ref_submap = ref_img.submap(rectangle) #bottom_left, top_right=top_right)
	return ref_submap

def makeflat(files):
    '''
    Give a list of images spanning not more than 15-20 mins in time.
    Ideal for cleaning 2k NB03 images.
    '''
    template_map= Map(files[0])
    ref_submap = get_submap(template_map)
    ref_cdel=ref_submap.meta['CDELT1']
    seq = Map(files, sequence=True)
    align_shift = calculate_match_template_shift(seq, template=ref_submap)
    shift_xPix = align_shift['x'].value / ref_cdel * -1
    shift_yPix = align_shift['y'].value / ref_cdel * -1
    aligned_maps = apply_shifts(seq, yshift=shift_yPix * u.pixel, xshift=shift_xPix * u.pixel, clip=False)
    aligned_map_arr= np.stack([m.data for m in aligned_maps], axis=0)
    med= np.median(aligned_map_arr, axis=0)
    flat_frame= template_map.data/med
    return flat_frame

def fd_correction(file):
    """
    - To process images taken in the line channels
    NB03, NB04 and NB08
    """
    m= Map(file)
    corrected_img_data= m.data/flat_frame
    corrected_img_data= np.nan_to_num(corrected_img_data, nan=0.0)
    corrected_img_data[corrected_img_data> 6e4]=0
    corrected_map= Map(corrected_img_data, m.meta)
    if SAVE:
        filename= m.meta['F_NAME']
        img_savepath= os.path.join(project_path, f'products/full_disk/{filename}')
        corrected_map.save(img_savepath, overwrite=True)
        if not QUIET: print('FD saved:', filename)

if __name__=='__main__':
    SAVE= True # Toggle to save corrected image
    QUIET= False
    project_path= os.path.abspath('..')
    fd_files= sorted(glob.glob(os.path.join(project_path, f'data/raw/full_disk/*.fits'))) # Filepath for full disk images
    flat_frame= makeflat(fd_files[:15]) # Make flat file. Global variable
    with multiprocessing.Pool() as pool:
        pool.map(fd_correction, fd_files)
